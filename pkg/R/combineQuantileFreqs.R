#######################################################################
## File: combine.quantile.freqs.R
##
## Author: Peter S. Bazeley, University of Toledo
##
## Description: Code for
##
## The problem:
##
## Contains: combine.quantile.freqs
#######################################################################



#######################################################################
## Function: combine.quantile.freqs
##
## Description: For each gene
##
## Input:
##        d1.fr = Data frame for 1st dataset with genes as rows and score
##                frequencies as columns
##        d2.fr = Data frame for 2nd dataset with genes as rows and score
##                frequencies as columns
##        ID.map = Data frame with paired, mapped IDs for probes.
##
## Output:
##        data = data frame with genes as rows and quantile frequencies
##               (scores) as columns, 1 group after the other. Row 
##               names are, and any additional IDs are added as
##               additional columns on right.
##
#######################################################################


combineQuantileFreqs <- function(d1.fr,d2.fr,ID.map,ID.cols=c(1,2)) {
    options(warn=-1)

    
    if(length(ID.cols) != 2) {
        stop("ID.cols must be a vector of length 2, one value for each column index in ID.map that specifies platform IDs.")
    }
    
    ##check that inputs are data frames; convert to if otherwise
    if(!is.data.frame(d1.fr)) {

        if(is.matrix(d1.fr)) {
            d1.fr.df = data.frame(d1.fr,row.names=dimnames(d1.fr)[[1]])
            names(d1.fr.df) = dimnames(d1.fr)[[2]]
            d1.fr = d1.fr.df
        }
        else {
            stop("First frequency data table must be data frame or matrix.")
        }
    }
    if(!is.data.frame(d2.fr)) {
        
        if(is.matrix(d2.fr)) {
            d2.fr.df = data.frame(d2.fr,row.names=dimnames(d2.fr)[[1]])
            names(d2.fr.df) = dimnames(d2.fr)[[2]]
            d2.fr = d2.fr.df
        }
        else {
            stop("Second frequency data table must be data frame or matrix.")
        }
    }
    if(!is.data.frame(ID.map)) {
        
        if(is.matrix(ID.map)) {
            ID.map.df = data.frame(ID.map,row.names=dimnames(ID.map)[[1]])
            names(ID.map.df) = dimnames(ID.map)[[2]]
            ID.map = ID.map.df
        }
        else {
            stop("ID map must be data frame or matrix.")
        }
    }


    ##shouldn't be any NAs if scores generated from the package
    if(any(is.na(d1.fr))) {
        stop("Missing values are present in d1.fr. Missing values can be present in the raw expression data fed to get.quantile.scores, but not here. If your data was generated by get.quantile.freqs, and you get this message, this is a bug. Please contact the QuantCombine package maintainer. If you see values of -1000 in the the scores data generated by get.quantile.scores, this is okay. These values were missing in the original expression data, and are ignored by get.quantile.freqs.")
    }
    if(any(is.na(d1.fr))) {
        stop("Missing values are present in d2.fr. Missing values can be present in the raw expression data fed to get.quantile.scores, but not here. If your data was generated by get.quantile.freqs, and you get this message, this is a bug. Please contact the QuantCombine package maintainer. If you see values of -1000 in the the scores data generated by get.quantile.scores, this is okay. These values were missing in the original expression data, and are ignored by get.quantile.freqs.")
    }
    if(any(is.na(ID.map))) {
        stop("Missing values are present in ID.map. If you created ID.map and one of the ID columns has more rows than the other, please remove these unpaired rows. If you used one of the ID.maps contained in the package, this is a bug. Please contact the package maintainer.")
    }
        

    ID.map.ncol = ncol(ID.map)
    if ( (ID.cols[1] > ID.map.ncol) | (ID.cols[2] > ID.map.ncol) ) {
        stop("ID.cols must be column indices within ID.map")
    }
    
    
    ##check that inputs have genes as row names and not column 1
    if( (sum(d1.fr[,1] %in% ID.map[,ID.cols[1]])>0) | (sum(d1.fr[,1] %in% ID.map[,ID.cols[2]])>0) ) {
        d1.fr = data.frame(d1.fr[,2:ncol(d1.fr)],row.names=d1.fr[,1])
    }
    if( (sum(d2.fr[,1] %in% ID.map[,ID.cols[1]])>0) | (sum(d2.fr[,1] %in% ID.map[,ID.cols[2]])>0) ) {
        d2.fr = data.frame(d2.fr[,2:ncol(d2.fr)],row.names=d2.fr[,1])
    }

    
    ##subset common IDs
    d1.fr.common = d1.fr[as.character(ID.map[,ID.cols[1]]),]
    d2.fr.common = d2.fr[as.character(ID.map[,ID.cols[2]]),]
    
    ## if ID.map longer than data, will show up as NAs at bottom, so remove these
    d1.fr.common = d1.fr.common[!is.na.data.frame(d1.fr.common)[,1],]
    d2.fr.common = d2.fr.common[!is.na.data.frame(d2.fr.common)[,1],]

    ##check which columns have data and which have IDs
    f1 = function(x) {is.factor(d1.fr.common[1,x])}
    f2 = function(x) {is.factor(d2.fr.common[1,x])}

    d1.fr.common.IDs = sapply(1:ncol(d1.fr.common),f1)
    d2.fr.common.IDs = sapply(1:ncol(d2.fr.common),f2)

    
    ##store IDs from each data
    d1.fr.common.IDcols = data.frame(d1.fr.common[,d1.fr.common.IDs],row.names=row.names(d1.fr.common))
    names(d1.fr.common.IDcols) = names(d1.fr.common)[d1.fr.common.IDs]

    d2.fr.common.IDcols = data.frame(d2.fr.common[,d2.fr.common.IDs],row.names=row.names(d2.fr.common))
    names(d2.fr.common.IDcols) = names(d2.fr.common)[d2.fr.common.IDs]
    
    
    ##check that inputs have same number of columns and column labels
    if(ncol(d1.fr.common[,!d1.fr.common.IDs]) != ncol(d1.fr.common[,!d1.fr.common.IDs])) {
        stop("d1.fr and d2.fr must have same number of score frequency columns.")
    }

    ##merge datasets
    ##d1's IDs will prevail
    d.fr.common = d1.fr.common[,!d1.fr.common.IDs] + d2.fr.common[,!d2.fr.common.IDs]

    d1.fr.common.nonIDs.sum = sum(d1.fr.common.IDs==FALSE)
    names(d.fr.common) = names(d1.fr.common)[1:d1.fr.common.nonIDs.sum]
    
    ##d1's IDs prevailed in merge, so add d2's IDs to end
    ##e = merge(d.fr.common,ID.map, by.x = "row.names",by.y = names(ID.map)[d1.fr.IDcol])
    
    m = match(row.names(d.fr.common),ID.map[,ID.cols[1]])
    
    d.fr.common = cbind(d.fr.common,ID.map[m,ID.cols[2]])
    
    n = names(ID.map)[ID.cols[2]]
    
        
    attributes(d.fr.common)$names[ncol(d.fr.common)] = n




    
    d.fr.common.ncol = ncol(d.fr.common)
    
    d1.fr.common.IDs.sum = sum(d1.fr.common.IDs==TRUE)
    d2.fr.common.IDs.sum = sum(d2.fr.common.IDs==TRUE)
    
    if(d1.fr.common.IDs.sum > 0) {
        for(i in seq(1,d1.fr.common.IDs.sum)) {
            
            matches = d.fr.common[,d.fr.common.ncol] %in% d1.fr.common.IDcols[,i]
            
            if(sum(matches==TRUE) != length(matches)) {
                d.fr.common = cbind(d.fr.common,d1.fr.common.IDcols[,i])
                n = names(d1.fr.common.IDcols)[i]
                attributes(d.fr.common)$names[ncol(d.fr.common)] = n
            }
        }
    }
    
    if(d2.fr.common.IDs.sum > 0) {
        for(i in seq(1,d2.fr.common.IDs.sum)) {
            
            matches = d.fr.common[,d.fr.common.ncol] %in% d2.fr.common.IDcols[,i]
            
            if(sum(matches==TRUE) != length(matches)) {
                d.fr.common = cbind(d.fr.common,d2.fr.common.IDcols[,i])
                n = names(d2.fr.common.IDcols)[i]
                attributes(d.fr.common)$names[ncol(d.fr.common)] = n
            }
        }
    }
    
    
    return(d.fr.common)
}


##end of combineQuantileFreqs.R



